/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. spiff.jj */
/*@egen*/options{  STATIC = false;  DEBUG_TOKEN_MANAGER = false;  DEBUG_PARSER = false;                                                                                                                                                                                                                                }PARSER_BEGIN(SpiffTreeParser)/******************************************************************************* * This file is part of SPIFF. *  * SPIFF is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. *  * SPIFF is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. *  * You should have received a copy of the GNU General Public License * along with SPIFF.  If not, see <http://www.gnu.org/licenses/>. ******************************************************************************/package com.revbingo.spiff.parser.gen;import com.revbingo.spiff.AdfFormatException;import com.revbingo.spiff.instructions.*;import com.revbingo.spiff.datatypes.*;import com.revbingo.spiff.evaluator.Evaluator;import com.revbingo.spiff.parser.InstructionParser;import java.util.*;import java.nio.ByteOrder;import java.nio.charset.Charset;public class SpiffTreeParser/*@bgen(jjtree)*/implements SpiffTreeParserTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected JJTSpiffTreeParserState jjtree = new JJTSpiffTreeParserState();

/*@egen*/}PARSER_END(SpiffTreeParser)SKIP :{  " " | "\t"}TOKEN : /* TYPES */{  < TY_STRING : "string" >| < TY_INT : "int" >| < TY_LONG : "long" >| < TY_BYTE : "byte" >| < TY_SHORT : "short" >| < TY_DOUBLE : "double" >| < TY_FLOAT : "float" >| < TY_UBYTE : "ubyte" >| < TY_USHORT : "ushort" >| < TY_UINT : "uint" >| < TY_ULONG : "ulong" >| < TY_BITS : "bits" >| < TY_BYTES : "bytes" >}TOKEN : /* LITERALS */{  < EOL :    "\n"  | "\r"  | "\r\n" >| < BYTEORDER :    "LITTLE_ENDIAN"  | "BIG_ENDIAN" >| < ENCODING :    "UTF-16LE"  | "UTF-16BE"  | "UTF-8"  | "US-ASCII" >| < END :    "end"  | "END" >| < OPEN_PAR : "(" >| < CLOSE_PAR : ")" >| < OPEN_BRACE : "{" >| < CLOSE_BRACE : "}" >| < COMMA : "," >| < QUOTE : "'" >}TOKEN : /* INSTRUCTIONS */{  < INS_JUMP : ".jump" >| < INS_SETORDER : ".setorder" >| < INS_REPEAT : ".repeat" >| < INS_GROUP : ".group" >| < INS_SKIP : ".skip" >| < INS_IF : ".if" >| < INS_SET : ".set" >| < INS_PRINT : ".print" >| < INS_ELSE : ".else" >| < INS_MARK : ".mark" >| < INS_SETENCODING : ".setencoding" >| < INS_DEFINE : ".define" >| < INS_INCLUDE : ".include" >| < INS_DATATYPE : ".datatype" >}TOKEN : /* OPERATORS */{  < EQUAL : "==" >| < GREATER_THAN : ">" >| < LESS_THAN : "<" >| < NOT_EQUAL : "!=" >| < GREATER_OR_EQUAL : ">=" >| < LESS_OR_EQUAL : "<=" >| < PL_MI_OPERATOR : "+" | "-" >| < MUL_DIV_OPERATOR : "*" | "/" | "%" >}TOKEN : /* OTHERS */{ < IDENTIFIER : (< ALPHA > | < UNDERSCORE >) (< ALPHANUM > | < UNDERSCORE >)* >| < ID_VALUE : < IDENTIFIER > ".value" >| < CLASS : (<ALPHA>)+ (("."|"$") (<ALPHANUM>)+ )* >| < ID_ADDRESS : "&" < IDENTIFIER > >| < COMMENT : "#" (~[ "\n", "\r" ])* >| < FLOAT : (< DIGIT >)+ "." (< DIGIT >)+ >| < HEX_INTEGER : "0x" (["A"-"F","a"-"f","0"-"9"])* >| < INTEGER :  (< DIGIT >)+ >| < #ALPHANUM : < ALPHA > | < DIGIT > >| < #DIGIT : [ "0"-"9" ] >| < #ALPHA : [ "a"-"z", "A"-"Z" ] >| < #UNDERSCORE : "_" >}ASTadf adf() : {/*@bgen(jjtree) adf */
  ASTadf jjtn000 = new ASTadf(JJTADF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) adf */
  try {
/*@egen*/  datatypeDefs()  list()  (< EOL >)*   < EOF >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/    { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}void datatypeDefs()       : {}{	(/*@bgen(jjtree) datatypeDef */
         {
           ASTdatatypeDef jjtn001 = new ASTdatatypeDef(JJTDATATYPEDEF);
           boolean jjtc001 = true;
           jjtree.openNodeScope(jjtn001);
           jjtn001.jjtSetFirstToken(getToken(1));
         }
         try {
/*@egen*/(<INS_DATATYPE> <IDENTIFIER> <CLASS> <EOL>)/*@bgen(jjtree)*/
         } finally {
           if (jjtc001) {
             jjtree.closeNodeScope(jjtn001, true);
             jjtn001.jjtSetLastToken(getToken(0));
           }
         }
/*@egen*/             )*}void list() :{/*@bgen(jjtree) list */
  ASTlist jjtn000 = new ASTlist(JJTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) list */
  try {
/*@egen*/  (    [      (        entry()      |         instruction()      )    ]    [ < COMMENT > ]     < EOL >  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}void entry() :{/*@bgen(jjtree) entry */
  ASTentry jjtn000 = new ASTentry(JJTENTRY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/ Token t1, t2; }{/*@bgen(jjtree) entry */
  try {
/*@egen*/  (    LOOKAHEAD(8)    string()  |     LOOKAHEAD(2)    fixedNumber()  |  	bits()  |   	bytes()  |	    userDefinedType()  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}void bits() : {/*@bgen(jjtree) bits */
  ASTbits jjtn000 = new ASTbits(JJTBITS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) bits */
        try {
/*@egen*/	<TY_BITS> <OPEN_PAR> expression() <CLOSE_PAR> <IDENTIFIER>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
        }
/*@egen*/}void bytes() : {/*@bgen(jjtree) bytes */
  ASTbytes jjtn000 = new ASTbytes(JJTBYTES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) bytes */
        try {
/*@egen*/	<TY_BYTES> <OPEN_PAR> expression() <CLOSE_PAR> <IDENTIFIER>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
        }
/*@egen*/}void userDefinedType() : {/*@bgen(jjtree) userDefinedType */
  ASTuserDefinedType jjtn000 = new ASTuserDefinedType(JJTUSERDEFINEDTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) userDefinedType */
        try {
/*@egen*///user defined datatype  	<IDENTIFIER> <IDENTIFIER>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
        }
/*@egen*/  	}void fixedNumber() :{/*@bgen(jjtree) fixedNumber */
  ASTfixedNumber jjtn000 = new ASTfixedNumber(JJTFIXEDNUMBER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) fixedNumber */
        try {
/*@egen*/ 	numberType() <IDENTIFIER>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
        }
/*@egen*/}void numberType()       : {}{  (    < TY_DOUBLE >  | < TY_INT >  | < TY_BYTE >  | < TY_FLOAT >  | < TY_SHORT >  | < TY_LONG >  | < TY_UBYTE >  | < TY_USHORT >  | < TY_ULONG >  | < TY_UINT >  )}void instruction()       :{}{  jumpInstruction()|   setOrderInstruction()|   repeatInstruction()|   groupInstruction()|   skipInstruction()|   ifElseBlock()|   setInstruction()|   markInstruction()|   setEncodingInstruction()|   defineInstruction()|   includeInstruction()}void string()       :{}{  (  	LOOKAHEAD(3)  	literalString()  |    LOOKAHEAD(3)    fixedString()  |     LOOKAHEAD(3)    terminatedString()  )  }void includeInstruction() : {/*@bgen(jjtree) includeInstruction */
  ASTincludeInstruction jjtn000 = new ASTincludeInstruction(JJTINCLUDEINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) includeInstruction */
  try {
/*@egen*/  <INS_INCLUDE> <IDENTIFIER>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}void defineInstruction() : {/*@bgen(jjtree) defineInstruction */
  ASTdefineInstruction jjtn000 = new ASTdefineInstruction(JJTDEFINEINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) defineInstruction */
  try {
/*@egen*/  <INS_DEFINE>   <OPEN_PAR>   	<IDENTIFIER>   <CLOSE_PAR>   <OPEN_BRACE>   list()   <CLOSE_BRACE>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}void setEncodingInstruction() : {/*@bgen(jjtree) setEncodingInstruction */
  ASTsetEncodingInstruction jjtn000 = new ASTsetEncodingInstruction(JJTSETENCODINGINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) setEncodingInstruction */
  try {
/*@egen*/  <INS_SETENCODING> <ENCODING>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}void setInstruction() : {/*@bgen(jjtree) setInstruction */
  ASTsetInstruction jjtn000 = new ASTsetInstruction(JJTSETINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) setInstruction */
  try {
/*@egen*/  <INS_SET> <IDENTIFIER> expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}void ifElseBlock() : {/*@bgen(jjtree) ifElseBlock */
  ASTifElseBlock jjtn000 = new ASTifElseBlock(JJTIFELSEBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) ifElseBlock */
  try {
/*@egen*/  <INS_IF> <OPEN_PAR> expression() <CLOSE_PAR>   <OPEN_BRACE>     list()   <CLOSE_BRACE>  [    LOOKAHEAD(2)    [ <EOL> ]     <INS_ELSE> [ <EOL> ]    <OPEN_BRACE>       list()     <CLOSE_BRACE>  ]/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}void setOrderInstruction() : {/*@bgen(jjtree) setOrderInstruction */
  ASTsetOrderInstruction jjtn000 = new ASTsetOrderInstruction(JJTSETORDERINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) setOrderInstruction */
  try {
/*@egen*/  <INS_SETORDER> <BYTEORDER>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}void repeatInstruction() : {/*@bgen(jjtree) repeatInstruction */
  ASTrepeatInstruction jjtn000 = new ASTrepeatInstruction(JJTREPEATINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) repeatInstruction */
  try {
/*@egen*/  <INS_REPEAT> <OPEN_PAR> expression() <CLOSE_PAR>   <OPEN_BRACE>     list()   <CLOSE_BRACE>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}void groupInstruction() : {/*@bgen(jjtree) groupInstruction */
  ASTgroupInstruction jjtn000 = new ASTgroupInstruction(JJTGROUPINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) groupInstruction */
  try {
/*@egen*/  <INS_GROUP> <OPEN_PAR> <IDENTIFIER> <CLOSE_PAR>  <OPEN_BRACE>   	list()   <CLOSE_BRACE>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}void jumpInstruction() : {/*@bgen(jjtree) jumpInstruction */
  ASTjumpInstruction jjtn000 = new ASTjumpInstruction(JJTJUMPINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) jumpInstruction */
  try {
/*@egen*/  <INS_JUMP> expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}void skipInstruction() : {/*@bgen(jjtree) skipInstruction */
  ASTskipInstruction jjtn000 = new ASTskipInstruction(JJTSKIPINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) skipInstruction */
  try {
/*@egen*/  <INS_SKIP> expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}void markInstruction() : {/*@bgen(jjtree) markInstruction */
  ASTmarkInstruction jjtn000 = new ASTmarkInstruction(JJTMARKINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) markInstruction */
  try {
/*@egen*/  <INS_MARK> <IDENTIFIER>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}void fixedString()         : {/*@bgen(jjtree) string */
  ASTstring jjtn000 = new ASTstring(JJTSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) string */
  try {
/*@egen*/  { jjtn000.type = ASTstring.StringType.FIXED; }  <TY_STRING> <OPEN_PAR> expression()  [ <COMMA> <ENCODING>]  <CLOSE_PAR> <IDENTIFIER>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}void literalString()         :{/*@bgen(jjtree) string */
   ASTstring jjtn000 = new ASTstring(JJTSTRING);
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
   jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/   Token t;}{/*@bgen(jjtree) string */
  try {
/*@egen*/  { jjtn000.type = ASTstring.StringType.LITERAL; }  <TY_STRING> <OPEN_PAR>   	<QUOTE>   		t = <IDENTIFIER> { jjtn000.literal = t.image; }  	<QUOTE> 	[ <COMMA> <ENCODING> ]    <CLOSE_PAR> <IDENTIFIER>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}void terminatedString()         : {/*@bgen(jjtree) string */
  ASTstring jjtn000 = new ASTstring(JJTSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) string */
  try {
/*@egen*/  { jjtn000.type = ASTstring.StringType.TERMINATED; }  <TY_STRING>  [ <OPEN_PAR> <ENCODING> <CLOSE_PAR> ]  <IDENTIFIER>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/ }// ************ EXPRESSIONS ****************void expression() : {/*@bgen(jjtree) expression */
  ASTexpression jjtn000 = new ASTexpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) expression */
        try {
/*@egen*/	comparitiveExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtn000.jjtSetLastToken(getToken(0));
          }
        }
/*@egen*/}void comparitiveExpression()       : {}{  additiveExpression()  ( comparator() additiveExpression() )*}void comparator()       : {}{  (    <EQUAL>  | <GREATER_THAN>  | <LESS_THAN>  | <NOT_EQUAL>  | <LESS_OR_EQUAL>  | <GREATER_OR_EQUAL>  )}void additiveExpression()       : {}{  multiplicativeExpression()  ( <PL_MI_OPERATOR> multiplicativeExpression() )*}void multiplicativeExpression()       : {}{  unaryExpression()  ( <MUL_DIV_OPERATOR> unaryExpression() )*}void unaryExpression()       :{ Token t; }{  (    LOOKAHEAD(2) functionCall()  | [<PL_MI_OPERATOR>] <INTEGER>  | LOOKAHEAD(2) <IDENTIFIER>  | <HEX_INTEGER>  | <ID_ADDRESS>  | <ID_VALUE>  | <OPEN_PAR> comparitiveExpression() <CLOSE_PAR>  )}void functionCall()       : {}{  <IDENTIFIER> <OPEN_PAR> [ FormalParameters() ] <CLOSE_PAR>}void FormalParameters()       : {}{   FormalParameter() ( <COMMA> FormalParameter() )*}void FormalParameter()       : {}{  (     LOOKAHEAD(2)  comparitiveExpression()  | <IDENTIFIER>  | <INTEGER>  | <FLOAT>  | <ID_VALUE>  | <ID_ADDRESS>  )}