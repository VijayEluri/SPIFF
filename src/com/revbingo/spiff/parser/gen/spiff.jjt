options{  STATIC = false;  DEBUG_TOKEN_MANAGER = false;  DEBUG_PARSER = false;  VISITOR = true;  VISITOR_DATA_TYPE = "java.util.List<com.revbingo.spiff.instructions.Instruction>";  VISITOR_RETURN_TYPE = "java.util.List<com.revbingo.spiff.instructions.Instruction>";  MULTI = true;  TRACK_TOKENS = true;}PARSER_BEGIN(SpiffTreeParser)/******************************************************************************* * This file is part of SPIFF. *  * SPIFF is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. *  * SPIFF is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. *  * You should have received a copy of the GNU General Public License * along with SPIFF.  If not, see <http://www.gnu.org/licenses/>. ******************************************************************************/package com.revbingo.spiff.parser.gen;import com.revbingo.spiff.AdfFormatException;import com.revbingo.spiff.instructions.*;import com.revbingo.spiff.datatypes.*;import com.revbingo.spiff.evaluator.Evaluator;import com.revbingo.spiff.parser.InstructionParser;import java.util.*;import java.nio.ByteOrder;import java.nio.charset.Charset;public class SpiffTreeParser{  private List <Instruction> instructions = new ArrayList <Instruction> ();  private Stack <List<Instruction>> instructionStack = new Stack <List <Instruction>> ();  private Map <String, Class<Datatype>> datatypes = new HashMap<String, Class<Datatype>>();  private Evaluator evaluator = new Evaluator();    private String defaultEncoding = Charset.defaultCharset().displayName();  public void optimise() {    List <Instruction> allInsts = flatten(instructions);    for (Instruction i : allInsts) {      if (i instanceof Datatype) {        Datatype ri = (Datatype) i;        if (!evaluator.isReferenced(ri.getName())) {          ri.setReferenced(false);        }      }    }  }  public List<Instruction> getInstructions() {  	optimise();  	return instructions;  }    private List <Instruction> flatten(List <Instruction> insts) {    List <Instruction> a = new ArrayList <Instruction> ();    for (Instruction i : insts) {      if (i instanceof Block) {        a.addAll(flatten(((Block) i).getInstructions()));      } else {        a.add(i);      }    }    return a;  }}PARSER_END(SpiffTreeParser)SKIP :{  " " | "\t"}TOKEN : /* TYPES */{  < TY_STRING : "string" >| < TY_INT : "int" >| < TY_LONG : "long" >| < TY_BYTE : "byte" >| < TY_SHORT : "short" >| < TY_DOUBLE : "double" >| < TY_FLOAT : "float" >| < TY_UBYTE : "ubyte" >| < TY_USHORT : "ushort" >| < TY_UINT : "uint" >| < TY_ULONG : "ulong" >| < TY_BITS : "bits" >| < TY_BYTES : "bytes" >}TOKEN : /* LITERALS */{  < EOL :    "\n"  | "\r"  | "\r\n" >| < BYTEORDER :    "LITTLE_ENDIAN"  | "BIG_ENDIAN" >| < ENCODING :    "UTF-16LE"  | "UTF-16BE"  | "UTF-8"  | "US-ASCII" >| < END :    "end"  | "END" >| < OPEN_PAR : "(" >| < CLOSE_PAR : ")" >| < OPEN_BRACE : "{" >| < CLOSE_BRACE : "}" >| < COMMA : "," >| < QUOTE : "'" >}TOKEN : /* INSTRUCTIONS */{  < INS_JUMP : ".jump" >| < INS_SETORDER : ".setorder" >| < INS_REPEAT : ".repeat" >| < INS_GROUP : ".group" >| < INS_SKIP : ".skip" >| < INS_IF : ".if" >| < INS_SET : ".set" >| < INS_PRINT : ".print" >| < INS_ELSE : ".else" >| < INS_MARK : ".mark" >| < INS_SETENCODING : ".setencoding" >| < INS_DEFINE : ".define" >| < INS_INCLUDE : ".include" >| < INS_DATATYPE : ".datatype" >}TOKEN : /* OPERATORS */{  < EQUAL : "==" >| < GREATER_THAN : ">" >| < LESS_THAN : "<" >| < NOT_EQUAL : "!=" >| < GREATER_OR_EQUAL : ">=" >| < LESS_OR_EQUAL : "<=" >| < PL_MI_OPERATOR : "+" | "-" >| < MUL_DIV_OPERATOR : "*" | "/" | "%" >}TOKEN : /* OTHERS */{ < IDENTIFIER : (< ALPHA > | < UNDERSCORE >) (< ALPHANUM > | < UNDERSCORE >)* >| < ID_VALUE : < IDENTIFIER > ".value" >| < CLASS : (<ALPHA>)+ (("."|"$") (<ALPHANUM>)+ )* >| < ID_ADDRESS : "&" < IDENTIFIER > >| < COMMENT : "#" (~[ "\n", "\r" ])* >| < FLOAT : (< DIGIT >)+ "." (< DIGIT >)+ >| < HEX_INTEGER : "0x" (["A"-"F","a"-"f","0"-"9"])* >| < INTEGER :  (< DIGIT >)+ >| < #ALPHANUM : < ALPHA > | < DIGIT > >| < #DIGIT : [ "0"-"9" ] >| < #ALPHA : [ "a"-"z", "A"-"Z" ] >| < #UNDERSCORE : "_" >}ASTadf adf() : {}{  datatypeDefs()  list()  (< EOL >)*   < EOF >    { return jjtThis; }}void datatypeDefs() :{ Token id, clazz; }{	(		<INS_DATATYPE> (id=<IDENTIFIER>) (clazz=<CLASS>) <EOL>				{			try {				Class<Datatype> datatypeClass = (Class<Datatype>) Class.forName(clazz.image);				if(!Datatype.class.isAssignableFrom(datatypeClass)) {					throw new AdfFormatException("Custom datatype " + datatypeClass + " does not extend com.revbingo.spiff.datatypes.Datatype");				}				datatypes.put(id.image, datatypeClass);			} catch (ClassNotFoundException e) {				throw new AdfFormatException("Unknown datatype class " + clazz.image);			}					}	)*}void list() :{}{  (    [      (        entry()      |         instruction()      )    ]    [ < COMMENT > ]     < EOL >  )*}void entry() :{ Token t1, t2; }{  (    LOOKAHEAD(8)    string()  |     LOOKAHEAD(2)    fixedNumber()  |  	bits()  |   	bytes()  |	  	//user defined datatype  	(t1=<IDENTIFIER>) (t2=<IDENTIFIER>)  	  	{	  		Class<Datatype> userType = datatypes.get(t1.image);  		if(userType == null) {  			throw new AdfFormatException("Undefined datatype " + t1.image);  		}  		try {  			Datatype inst = userType.newInstance();  			inst.setName(t2.image);  			instructions.add(inst);  		} catch (InstantiationException e) {			throw new AdfFormatException("Custom datatype " + userType.getName() + " does not have a no-args constructor or threw an exception");		} catch (IllegalAccessException e) {			throw new AdfFormatException("Custom datatype " + userType.getName() + " does not have a publically accessible no args constructor");		}  	}  )}void bits() : {}{	<TY_BITS> <OPEN_PAR> expression() <CLOSE_PAR> <IDENTIFIER>}void bytes() : {}{	<TY_BYTES> <OPEN_PAR> expression() <CLOSE_PAR> <IDENTIFIER>}void fixedNumber() :{}{ 	numberType() <IDENTIFIER>}void numberType() #void : {}{  (    < TY_DOUBLE >  | < TY_INT >  | < TY_BYTE >  | < TY_FLOAT >  | < TY_SHORT >  | < TY_LONG >  | < TY_UBYTE >  | < TY_USHORT >  | < TY_ULONG >  | < TY_UINT >  )}void instruction() :{}{  jumpInstruction()|   setOrderInstruction()|   repeatInstruction()|   groupInstruction()|   skipInstruction()|   ifInstruction()|   setInstruction()|   markInstruction()|   setEncodingInstruction()|   defineInstruction()|   includeInstruction()}void string() #void :{}{  (  	LOOKAHEAD(3)  	literalString()  |    LOOKAHEAD(3)    fixedString()  |     LOOKAHEAD(3)    terminatedString()  )  }void includeInstruction() : {}{  <INS_INCLUDE> <IDENTIFIER>}void defineInstruction() : {}{  <INS_DEFINE>   <OPEN_PAR>   	<IDENTIFIER>   <CLOSE_PAR>   <OPEN_BRACE>   list()   <CLOSE_BRACE>}void setEncodingInstruction() : {}{  <INS_SETENCODING> <ENCODING>}void setInstruction() : {}{  <INS_SET> <IDENTIFIER> expression()}void ifInstruction() :{  String s;}{  {    instructionStack.push(instructions);    instructions = new ArrayList < Instruction > ();    IfBlock ins = new IfBlock();  }  < INS_IF >   < OPEN_PAR >  (    s = expression()  )  < CLOSE_PAR >   < OPEN_BRACE >   list()   < CLOSE_BRACE >  {    ins.setIfExpression(s);    ins.setInstructions(instructions);    instructions = instructionStack.pop();  }  [    LOOKAHEAD(2)    [ < EOL > ]     < INS_ELSE >     [ < EOL > ]    {      instructionStack.push(instructions);      instructions = new ArrayList < Instruction > ();    }    < OPEN_BRACE >     list()     < CLOSE_BRACE >    {      ins.setElseInstructions(instructions);      instructions = instructionStack.pop();    }  ]  {    instructions.add(ins);  }}void setOrderInstruction() : {}{  <INS_SETORDER> <BYTEORDER>}void repeatInstruction() :{  String s;}{  {    instructionStack.push(instructions);    instructions = new ArrayList < Instruction > ();  }  < INS_REPEAT >   < OPEN_PAR >  (    s = expression()  )  < CLOSE_PAR >   < OPEN_BRACE >   list()   < CLOSE_BRACE >  {    RepeatBlock ins = new RepeatBlock();    ins.setRepeatCountExpression(s);    ins.setInstructions(instructions);    instructions = instructionStack.pop();    instructions.add(ins);  }}void groupInstruction() : {}{  <INS_GROUP> <OPEN_PAR> <IDENTIFIER> <CLOSE_PAR>  <OPEN_BRACE>   	list()   <CLOSE_BRACE>}void jumpInstruction() : {}{  <INS_JUMP> expression()}void skipInstruction() : {}{  <INS_SKIP> expression()}void markInstruction() : {}{  <INS_MARK> <IDENTIFIER>}void fixedString() #string : {}{  { jjtThis.type = ASTstring.StringType.FIXED; }  <TY_STRING> <OPEN_PAR> expression()  [ <COMMA> <ENCODING>]  <CLOSE_PAR> <IDENTIFIER>}void literalString() #string :{   Token t;}{  { jjtThis.type = ASTstring.StringType.LITERAL; }  <TY_STRING> <OPEN_PAR>   	<QUOTE>   		t = <IDENTIFIER> { jjtThis.literal = t.image; }  	<QUOTE> 	[ <COMMA> <ENCODING> ]    <CLOSE_PAR> <IDENTIFIER>}void terminatedString() #string : {}{  { jjtThis.type = ASTstring.StringType.TERMINATED; }  <TY_STRING>  [ <OPEN_PAR> <ENCODING> <CLOSE_PAR> ]  <IDENTIFIER> }// ************ EXPRESSIONS ****************String expression() :{ String s; }{	s=comparitiveExpression()		{return s;}}String comparitiveExpression() #void :{  String s;  Token t;}{  {StringBuffer b = new StringBuffer();}    (s = additiveExpression())  { b.append(s); }    (    (t = comparator())  { b.append(t.image); }    (s = additiveExpression())  { b.append(s); }  )*    {    return b.toString();  }}Token comparator() #void :{  Token t;}{  (    (t = < EQUAL >)  |     (t = < GREATER_THAN >)  |     (t = < LESS_THAN >)  |     (t = < NOT_EQUAL >)  |     (t = < LESS_OR_EQUAL >)  |     (t = < GREATER_OR_EQUAL >)  )  {    return t;  }}String additiveExpression() #void :{  Token t;  String s;}{  { StringBuffer expr = new StringBuffer(); }   s = multiplicativeExpression()      {   expr.append(s); } (    t = < PL_MI_OPERATOR >            { expr.append(t.image); }    s = multiplicativeExpression()    {  expr.append(s); }  )*  { return expr.toString();  }}String multiplicativeExpression() #void :{  String s;  Token t;}{  { StringBuffer term = new StringBuffer(); }    s = unaryExpression()  {  term.append(s);  }  (    t = < MUL_DIV_OPERATOR > { term.append(t.image); }    s = unaryExpression()    { term.append(s); }  )*  { return term.toString(); }}String unaryExpression() #void :{ Token t; String ex; }{  { StringBuffer s = new StringBuffer(); }  (    LOOKAHEAD(2)    ex = functionCall()  {  s.append(ex); }  |	[t=<PL_MI_OPERATOR> { s.append(t.image); } ] t=<INTEGER> { s.append(t.image); }  |   	  LOOKAHEAD(2)      t = < IDENTIFIER >      {      s.append(t.image);      evaluator.cacheExpression(t.image);    }  |   	(t = < HEX_INTEGER >)  	{  		s.append(t.image);  	}  |    (t = < ID_ADDRESS >)    {      String s1 = t.image;      s.append(s1.substring(1, s1.length()) + ".address");      evaluator.cacheExpression(t.image);    }  |     (t = < ID_VALUE >)    {      s.append(t.image);      evaluator.cacheExpression(t.image);    }  |     (t = < OPEN_PAR >)    {      s.append(t.image);    }    (      ex = comparitiveExpression()    )    {      s.append(ex);    }    (t = < CLOSE_PAR >)    {      s.append(t.image);    }  )  {    return s.toString();  }}String functionCall() #void :{  Token t;  String ex;}{  (t = < IDENTIFIER >)   < OPEN_PAR >  (    ex = FormalParameters()  )  < CLOSE_PAR >  {    StringBuffer b = new StringBuffer();    b.append(t.image);    b.append(ex);    return b.toString();  }}String FormalParameters() #void :{  String ex;}{  {    StringBuffer b = new StringBuffer();    b.append("(");  }  [    (      ex = FormalParameter()    )    {      b.append(ex);    }    (      ","      (        ex = FormalParameter()      )      {        b.append(",");        b.append(ex);      }    )*  ]  {    b.append(")");    return b.toString();  }}String FormalParameter() #void :{  Token t = null;  String expr;}{  (      LOOKAHEAD(2)      (expr = comparitiveExpression())      { return expr; }  |    (t = < IDENTIFIER >)    {      evaluator.cacheExpression(t.image);    }  |     (t = < INTEGER >)  |     (t = < FLOAT >)  |     (t = < ID_VALUE >)    {      evaluator.cacheExpression(t.image);    }  |     (t = < ID_ADDRESS >)    {      evaluator.cacheExpression(t.image);    }      )  {    return t.image;  }}
