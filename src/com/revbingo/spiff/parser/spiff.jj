options{  STATIC = false;  DEBUG_TOKEN_MANAGER = false;  DEBUG_PARSER = false;}PARSER_BEGIN(SpiffParser)/******************************************************************************* * This file is part of SPIFF. *  * SPIFF is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. *  * SPIFF is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. *  * You should have received a copy of the GNU General Public License * along with SPIFF.  If not, see <http://www.gnu.org/licenses/>. ******************************************************************************/package com.revbingo.spiff.parser;import com.revbingo.spiff.AdfFormatException;import com.revbingo.spiff.instructions.*;import com.revbingo.spiff.datatypes.*;import com.revbingo.spiff.evaluator.Evaluator;import com.revbingo.spiff.parser.InstructionParser;import java.util.*;import java.nio.ByteOrder;import java.nio.charset.Charset;public class SpiffParser implements InstructionParser{  private List <Instruction> instructions = new ArrayList <Instruction> ();  private Stack <List<Instruction>> instructionStack = new Stack <List <Instruction>> ();  private Map <String, List<Instruction>> defines = new HashMap <String, List<Instruction>> ();  private Map <String, Class<Datatype>> datatypes = new HashMap<String, Class<Datatype>>();  private Evaluator evaluator = new Evaluator();    private String defaultEncoding = Charset.defaultCharset().displayName();  public void optimise() {    List <Instruction> allInsts = flatten(instructions);    for (Instruction i : allInsts) {      if (i instanceof Datatype) {        Datatype ri = (Datatype) i;        if (!evaluator.isReferenced(ri.getName())) {          ri.setReferenced(false);        }      }    }  }  private List <Instruction> flatten(List <Instruction> insts) {    List <Instruction> a = new ArrayList <Instruction> ();    for (Instruction i : insts) {      if (i instanceof Block) {        a.addAll(flatten(((Block) i).getInstructions()));      } else {        a.add(i);      }    }    return a;  }}PARSER_END(SpiffParser)SKIP :{  " " | "\t"}TOKEN : /* TYPES */{  < TY_STRING : "string" >| < TY_INT : "int" >| < TY_LONG : "long" >| < TY_BYTE : "byte" >| < TY_SHORT : "short" >| < TY_DOUBLE : "double" >| < TY_FLOAT : "float" >| < TY_UBYTE : "ubyte" >| < TY_USHORT : "ushort" >| < TY_UINT : "uint" >| < TY_ULONG : "ulong" >| < TY_BITS : "bits" >| < TY_BYTES : "bytes" >}TOKEN : /* LITERALS */{  < EOL :    "\n"  | "\r"  | "\r\n" >| < BYTEORDER :    "LITTLE_ENDIAN"  | "BIG_ENDIAN" >| < ENCODING :    "UTF-16LE"  | "UTF-16BE"  | "UTF-8"  | "US-ASCII" >| < END :    "end"  | "END" >| < OPEN_PAR : "(" >| < CLOSE_PAR : ")" >| < OPEN_BRACE : "{" >| < CLOSE_BRACE : "}" >| < COMMA : "," >| < QUOTE : "'" >}TOKEN : /* INSTRUCTIONS */{  < INS_JUMP : ".jump" >| < INS_SETORDER : ".setorder" >| < INS_REPEAT : ".repeat" >| < INS_GROUP : ".group" >| < INS_SKIP : ".skip" >| < INS_IF : ".if" >| < INS_SET : ".set" >| < INS_PRINT : ".print" >| < INS_ELSE : ".else" >| < INS_MARK : ".mark" >| < INS_SETENCODING : ".setencoding" >| < INS_DEFINE : ".define" >| < INS_INCLUDE : ".include" >| < INS_DATATYPE : ".datatype" >}TOKEN : /* OPERATORS */{  < EQUAL : "==" >| < GREATER_THAN : ">" >| < LESS_THAN : "<" >| < NOT_EQUAL : "!=" >| < GREATER_OR_EQUAL : ">=" >| < LESS_OR_EQUAL : "<=" >| < PL_MI_OPERATOR : "+" | "-" >| < MUL_DIV_OPERATOR : "*" | "/" | "%" >}TOKEN : /* OTHERS */{ < IDENTIFIER : (< ALPHA > | < UNDERSCORE >) (< ALPHANUM > | < UNDERSCORE >)* >| < ID_VALUE : < IDENTIFIER > ".value" >| < CLASS : (<ALPHA>)+ (("."|"$") (<ALPHANUM>)+ )* >| < ID_ADDRESS : "&" < IDENTIFIER > >| < COMMENT : "#" (~[ "\n", "\r" ])* >| < FLOAT : (< DIGIT >)+ "." (< DIGIT >)+ >| < HEX_INTEGER : "0x" (["A"-"F","a"-"f","0"-"9"])* >| < INTEGER : ("-")? (< DIGIT >)+ >| < #ALPHANUM : < ALPHA > | < DIGIT > >| < #DIGIT : [ "0"-"9" ] >| < #ALPHA : [ "a"-"z", "A"-"Z" ] >| < #UNDERSCORE : "_" >}List<Instruction> parse() : {}{  datatypeDefs()  list()  (< EOL >)*   < EOF >    {    this.optimise();    return instructions;  }}void datatypeDefs() :{ Token id, clazz; }{	(		<INS_DATATYPE> (id=<IDENTIFIER>) (clazz=<CLASS>) <EOL>				{			try {				Class<Datatype> datatypeClass = (Class<Datatype>) Class.forName(clazz.image);				if(!Datatype.class.isAssignableFrom(datatypeClass)) {					throw new AdfFormatException("Custom datatype " + datatypeClass + " does not extend com.revbingo.spiff.datatypes.Datatype");				}				datatypes.put(id.image, datatypeClass);			} catch (ClassNotFoundException e) {				throw new AdfFormatException("Unknown datatype class " + clazz.image);			}					}	)*}void list() :{}{  (    [      (        entry()      |         instruction()      )    ]    [ < COMMENT > ]     < EOL >  )*}void entry() :{ Token t1, t2; }{  (    LOOKAHEAD(8)    string()  |     LOOKAHEAD(2)    fixedNumber()  |     LOOKAHEAD(2)    fixedUnsigned()  |  	bits()  |   	bytes()  |	  	//user defined datatype  	(t1=<IDENTIFIER>) (t2=<IDENTIFIER>)  	  	{	  		Class<Datatype> userType = datatypes.get(t1.image);  		if(userType == null) {  			throw new AdfFormatException("Undefined datatype " + t1.image);  		}  		try {  			Datatype inst = userType.newInstance();  			inst.setName(t1.image);  			instructions.add(inst);  		} catch (InstantiationException e) {			throw new AdfFormatException("Custom datatype " + userType.getName() + " does not have a no-args constructor or threw an exception");		} catch (IllegalAccessException e) {			throw new AdfFormatException("Custom datatype " + userType.getName() + " does not have a publically accessible no args constructor");		}  	}  )}void bits() :{ 	Token t2; 	String expr;}{	<TY_BITS> <OPEN_PAR> (expr = expression()) < CLOSE_PAR> (t2=<IDENTIFIER>)		{		BitsInstruction inst = new BitsInstruction();		inst.setName(t2.image);		inst.setNumberOfBitsExpr(expr);				instructions.add(inst);	}	}void bytes() :{ 	Token t2; 	String expr;}{	<TY_BYTES> <OPEN_PAR> (expr = expression()) < CLOSE_PAR> (t2=<IDENTIFIER>)		{		BytesInstruction inst = new BytesInstruction();		inst.setName(t2.image);		inst.setLengthExpr(expr);				instructions.add(inst);	}	}void instruction() :{}{  jumpInstruction()|   setOrderInstruction()|   repeatInstruction()|   groupInstruction()|   skipInstruction()|   ifInstruction()|   setInstruction()|   printInstruction()|   markInstruction()|   setEncodingInstruction()|   defineInstruction()|   includeInstruction()}void string() :{}{  (  	LOOKAHEAD(3)  	literalString()  |    LOOKAHEAD(3)    fixedString()  |     LOOKAHEAD(3)    terminatedString()  )  }void includeInstruction() :{  Token t;}{  < INS_INCLUDE >   (t = < IDENTIFIER >)  {    List<Instruction> include = defines.get(t.image);    if (include == null) {    	throw new AdfFormatException("Could not get defined block with name " + t.image);    }    instructions.addAll(include);  }}void defineInstruction() :{  Token t;}{  {    instructionStack.push(instructions);    instructions = new ArrayList < Instruction > ();  }  < INS_DEFINE >   < OPEN_PAR >   (t = < IDENTIFIER >)   < CLOSE_PAR >   < OPEN_BRACE >   list()   < CLOSE_BRACE >  {    defines.put(t.image, instructions);    instructions = instructionStack.pop();  }}void setEncodingInstruction() :{  Token t;}{  < INS_SETENCODING >   (t = < ENCODING >)  {    this.defaultEncoding = t.image;  }}void setInstruction() :{  String s;  Token t;}{  < INS_SET >   (t = < IDENTIFIER >)  (    s = expression()  )  {    SetInstruction ins = new SetInstruction();    ins.setVarname(t.image);    ins.setExpression(s);    instructions.add(ins);  }}void printInstruction() :{  Token t;  String s;}{  {    PrintInstruction ins = new PrintInstruction();  }  < INS_PRINT >  (    LOOKAHEAD(3)    (      s = expression()      {        ins.setVar(s);      }    )  |     LOOKAHEAD(3)    (      t = < IDENTIFIER >      {        ins.setVar(t.image);      }    )  )  {    instructions.add(ins);  }}void ifInstruction() :{  String s;}{  {    instructionStack.push(instructions);    instructions = new ArrayList < Instruction > ();    IfBlock ins = new IfBlock();  }  < INS_IF >   < OPEN_PAR >  (    s = expression()  )  < CLOSE_PAR >   < OPEN_BRACE >   list()   < CLOSE_BRACE >  {    ins.setIfExpression(s);    ins.setInstructions(instructions);    instructions = instructionStack.pop();  }  [    LOOKAHEAD(2)    [ < EOL > ]     < INS_ELSE >     [ < EOL > ]    {      instructionStack.push(instructions);      instructions = new ArrayList < Instruction > ();    }    < OPEN_BRACE >     list()     < CLOSE_BRACE >    {      ins.setElseInstructions(instructions);      instructions = instructionStack.pop();    }  ]  {    instructions.add(ins);  }}void setOrderInstruction() :{  Token t;}{  < INS_SETORDER >   (t = < BYTEORDER >)  {    SetOrderInstruction ins = new SetOrderInstruction();    ByteOrder order = null;    if (t.image.equals("LITTLE_ENDIAN"))    {      order = ByteOrder.LITTLE_ENDIAN;    }    else    {      order = ByteOrder.BIG_ENDIAN;    }    ins.setOrder(order);    instructions.add(ins);  }}void repeatInstruction() :{  String s;}{  {    instructionStack.push(instructions);    instructions = new ArrayList < Instruction > ();  }  < INS_REPEAT >   < OPEN_PAR >  (    s = expression()  )  < CLOSE_PAR >   < OPEN_BRACE >   list()   < CLOSE_BRACE >  {    RepeatBlock ins = new RepeatBlock();    ins.setRepeatCountExpression(s);    ins.setInstructions(instructions);    instructions = instructionStack.pop();    instructions.add(ins);  }}void groupInstruction() :{  Token t;}{  < INS_GROUP >   < OPEN_PAR >   (t = < IDENTIFIER >)   < CLOSE_PAR >  {    GroupInstruction ins = new GroupInstruction();    ins.setGroupName(t.image);    instructions.add(ins);  }  < OPEN_BRACE >   list()   < CLOSE_BRACE >  {    EndGroupInstruction ins2 = new EndGroupInstruction();    ins2.setGroupName(t.image);    instructions.add(ins2);  }}void jumpInstruction() :{  String s;}{  (< INS_JUMP >)  (    (      s = expression()    )  )  {    JumpInstruction ins = new JumpInstruction();    ins.setExpression(s);    instructions.add(ins);  }}void skipInstruction() :{  String s;}{  < INS_SKIP >  (    s = expression()  )  {    SkipInstruction ins = new SkipInstruction();    ins.setSizeExpression(s);    instructions.add(ins);  }}void markInstruction() :{  Token t;}{  < INS_MARK >   (t = < IDENTIFIER >)  {    MarkInstruction ins = new MarkInstruction();    ins.setName(t.image);    instructions.add(ins);  }}void fixedString() :{  Token t4, t5;  String s;}{  {   	String encoding = defaultEncoding;   }  < TY_STRING >   < OPEN_PAR >  (    s = expression()  )  [    < COMMA > (t5 = < ENCODING >)    {     	encoding = t5.image;    }  ]  < CLOSE_PAR >   (t4 = < IDENTIFIER >)  {  	FixedLengthString ins = new FixedLengthString(encoding);    ins.setLengthExpr(s);    ins.setName(t4.image);    instructions.add(ins);  }}void literalString() :{   Token t1, t4, t5;}{  <TY_STRING>     {   	String encoding = defaultEncoding;   }   <OPEN_PAR>   	<QUOTE>   		(t1 = <IDENTIFIER>)  	<QUOTE> 	[ < COMMA > (t5 = < ENCODING >)	    {	      encoding = t5.image;	    }	 ]    <CLOSE_PAR>  (t4 = < IDENTIFIER >)      {   	LiteralStringInstruction ins = new LiteralStringInstruction(encoding);   	instructions.add(ins);   	ins.setName(t4.image);   	ins.setLiteral(t1.image);   } }void terminatedString() :{  Token t2, t3;}{  {	String encoding = defaultEncoding;     }  < TY_STRING >  [    < OPEN_PAR > (t3 = < ENCODING >) < CLOSE_PAR >    {      encoding = t3.image;    }  ]  (t2 = < IDENTIFIER >)  {   	TerminatedString ins = new TerminatedString(encoding);    ins.setName(t2.image);    instructions.add(ins);  }}void fixedNumber() :{  Token t2, t4;}{  (    t2 = numberType()  )  (t4 = < IDENTIFIER >)  {    FixedLengthNumberFactory insF = new FixedLengthNumberFactory();    Datatype ins = insF.getInstruction(t2.image);    ins.setName(t4.image);    instructions.add(ins);  }}void fixedUnsigned() :{  Token t1, t2;}{  (    t1 = unsignedNumberType()  )  (t2 = < IDENTIFIER >)  {    FixedLengthUnsignedNumber ins = null;    if (t1.image.equals("uint"))    {      ins = new UnsignedIntegerInstruction();    }    else if (t1.image.equals("ubyte"))    {      ins = new UnsignedByteInstruction();    }    else if (t1.image.equals("ulong"))    {      ins = new UnsignedLongInstruction();    }    else if (t1.image.equals("ushort"))    {      ins = new UnsignedShortInstruction();    }    ins.setName(t2.image);    instructions.add(ins);  }}String expression() :{  String s;  Token t;}{  {StringBuffer b = new StringBuffer();}    (s = additiveExpression())  { b.append(s); }    (    (t = comparator())  { b.append(t.image); }    (s = additiveExpression())  { b.append(s); }  )*    {    return b.toString();  }}Token comparator() :{  Token t;}{  (    (t = < EQUAL >)  |     (t = < GREATER_THAN >)  |     (t = < LESS_THAN >)  |     (t = < NOT_EQUAL >)  |     (t = < LESS_OR_EQUAL >)  |     (t = < GREATER_OR_EQUAL >)  )  {    return t;  }}String additiveExpression() :{  Token t;  String s;}{  {    StringBuffer expr = new StringBuffer();  }  (    s = multiplicativeExpression()  )  {    expr.append(s);  }     (	    (t = < PL_MI_OPERATOR >)	    {	      expr.append(t.image);	    }	    (	      s = multiplicativeExpression()	    )	    {	      expr.append(s);	    }	  )*  {    return expr.toString();  }}String multiplicativeExpression() :{  String s;  Token t;}{  {    StringBuffer term = new StringBuffer();  }  (    s = unaryExpression()  )  {    term.append(s);  }  (    (t = < MUL_DIV_OPERATOR >)    {      term.append(t.image);    }    (      s = unaryExpression()    )    {      term.append(s);    }  )*  {    return term.toString();  }}String unaryExpression() :{  Token t;  String ex;}{  {    StringBuffer s = new StringBuffer();  }  (    LOOKAHEAD(2)    (      ex = functionCall()    )    {      s.append(ex);    }  |     (t = < IDENTIFIER >)    {      s.append(t.image);      evaluator.cacheExpression(t.image);    }  |     (t = < INTEGER >)    {      s.append(t.image);    }  |   	(t = < HEX_INTEGER>)  	{  		s.append(t.image);  	}  |    (t = < ID_ADDRESS >)    {      String s1 = t.image;      s.append(s1.substring(1, s1.length()) + ".address");      evaluator.cacheExpression(t.image);    }  |     (t = < ID_VALUE >)    {      s.append(t.image);      evaluator.cacheExpression(t.image);    }  |     (t = < OPEN_PAR >)    {      s.append(t.image);    }    (      ex = expression()    )    {      s.append(ex);    }    (t = < CLOSE_PAR >)    {      s.append(t.image);    }  )  {    return s.toString();  }}String functionCall() :{  Token t;  String ex;}{  (t = < IDENTIFIER >)   < OPEN_PAR >  (    ex = FormalParameters()  )  < CLOSE_PAR >  {    StringBuffer b = new StringBuffer();    b.append(t.image);    b.append(ex);    return b.toString();  }}String FormalParameters() :{  String ex;}{  {    StringBuffer b = new StringBuffer();    b.append("(");  }  [    (      ex = FormalParameter()    )    {      b.append(ex);    }    (      ","      (        ex = FormalParameter()      )      {        b.append(",");        b.append(ex);      }    )*  ]  {    b.append(")");    return b.toString();  }}String FormalParameter() :{  Token t = null;  String expr;}{  (      LOOKAHEAD(2)      (expr = expression())      { return expr; }  |    (t = < IDENTIFIER >)    {      evaluator.cacheExpression(t.image);    }  |     (t = < INTEGER >)  |     (t = < FLOAT >)  |     (t = < ID_VALUE >)    {      evaluator.cacheExpression(t.image);    }  |     (t = < ID_ADDRESS >)    {      evaluator.cacheExpression(t.image);    }      )  {    return t.image;  }}Token numberType() :{  Token t;}{  (    (t = < TY_DOUBLE >)  |     (t = < TY_INT >)  |     (t = < TY_BYTE >)  |     (t = < TY_FLOAT >)  |     (t = < TY_SHORT >)  |     (t = < TY_LONG >)  )  {    return t;  }}Token unsignedNumberType() :{  Token t;}{  (    (t = < TY_UBYTE >)  |     (t = < TY_USHORT >)  |     (t = < TY_ULONG >)  |     (t = < TY_UINT >)  )  {    return t;  }}
