options {
	STATIC=false;
	DEBUG_TOKEN_MANAGER=false; 
	DEBUG_PARSER=false;
}

PARSER_BEGIN(SpiffParser)
package com.revbingo.spiff.parser;

import com.revbingo.spiff.instructions.*;
import com.revbingo.spiff.evaluator.Evaluator;
import com.revbingo.spiff.parser.InstructionParser;
import java.util.*;
import java.nio.ByteOrder;

public class SpiffParser implements InstructionParser {

	List<Instruction> instructions = new ArrayList<Instruction>();
	Stack<List<Instruction>> instructionStack = new Stack<List<Instruction>>();
	Map<String, List<Instruction>> defines = new HashMap<String, List<Instruction>>();
	private String defaultEncoding = "UTF-8";
	
	public List<Instruction> getInstructions(){
		return instructions;
	}
	
	public void optimise(){
		List<Instruction> allInsts = flatten(instructions);
		for(Instruction i : allInsts) {
			if(i instanceof ReferencedInstruction) {
				ReferencedInstruction ri = (ReferencedInstruction) i;
				if(!Evaluator.isReferenced(ri.getName())) {
					ri.setReferenced(false);
				}
			}
		}
	}
	
	private List<Instruction> flatten(List<Instruction> insts){
		List<Instruction> a = new ArrayList<Instruction>();
		for(Instruction i : insts){
			if(i instanceof Block){
				a.addAll(flatten(((Block) i).getInstructions()));
			}else{
				a.add(i);
			}
		}
		return a;
	}
}
	
PARSER_END(SpiffParser)

SKIP: { " " | "\t" }
TOKEN:  	/* TYPES */ 
{ 
< TY_STRING : "string" > 
	| < TY_INT : "int" >	
	| < TY_LONG : "long" > 
	| < TY_BYTE : "byte" > 
	| < TY_SHORT : "short" > 
	| < TY_DOUBLE : "double" > 
	| < TY_FLOAT : "float" >
	| < TY_UBYTE : "ubyte" >
	| < TY_USHORT : "ushort" >
	| < TY_UINT  : "uint" >
	| < TY_ULONG : "ulong" >
}

TOKEN:  /* LITERALS */
{
	< EOL : "\n" | "\r" | "\r\n" >
	| < BYTEORDER: "LITTLE_ENDIAN" | "BIG_ENDIAN" >
	| < ENCODING : "UTF-16LE" | "UTF-16" | "UTF-8" | "US-ASCII" >
	| < END : "end" | "END" >
	| < OPEN_PAR : "(" >
	| < CLOSE_PAR : ")" >	
	| < OPEN_BRACE : "{" >
	| < CLOSE_BRACE : "}" >
	| < COMMA : "," >
	
}

TOKEN: /* INSTRUCTIONS */
{
	< INS_JUMP : ".jump" >
	| < INS_SETORDER : ".setorder" >
	| < INS_REPEAT : ".repeat" >
	| < INS_GROUP : ".group" >
	| < INS_SKIP : ".skip" >
	| < INS_IF	: ".if" >
	| < INS_SET : ".set" >
	| < INS_PRINT: ".print" >
	| < INS_ELSE : ".else" >
	| < INS_MARK : ".mark" >
	| < INS_SETENCODING : ".setencoding" >
	| < INS_DEFINE : ".define" >
	| < INS_INCLUDE : ".include" >  
}
	 
TOKEN: /* OPERATORS */
{ 
	< EQUAL : "==" >
	| < GREATER_THAN : ">" >
	| < LESS_THAN : "<" >
	| < NOT_EQUAL : "!=" >
	| < GREATER_OR_EQUAL : ">=" >
	| < LESS_OR_EQUAL : "<=" >
	| < PL_MI_OPERATOR : "+" | "-" >
	| < MUL_DIV_OPERATOR : "*" | "/" | "%" >
}

TOKEN:  /* OTHERS */
{ 
	< #DIGIT : ["0"-"9"] > 
	| < #ALPHA : ["a"-"z","A"-"Z"] > 
	| < #ALPHANUM : <ALPHA> | <DIGIT> >
	| < INTEGER : (<DIGIT>)+ > 
	| < FLOAT : (<DIGIT>)+"."(<DIGIT>)+ > 
	| < IDENTIFIER : <ALPHA>(<ALPHANUM>)* >
	| < ID_VALUE : <IDENTIFIER>".value" >
	| < ID_ADDRESS: "&"<IDENTIFIER> >
	| < COMMENT : "#"(~["\n", "\r"])*>
}

void start() : {}
{
	list()
	<END>
	(<EOL>)*
	<EOF>
	
	{ this.optimise(); }
}

void list() : {}
{
	(
		[( 
			entry() 
			|
			instruction()
		 )]
		[ <COMMENT> ]
		<EOL>
	)*
}
void entry() : {}
{
	(
		LOOKAHEAD(8)
		string()
	|
		LOOKAHEAD(2)
		fixedNumber()
	|
		LOOKAHEAD(2)
		fixedUnsigned()
	)
}

void instruction() : {}
{
	jumpInstruction()
	|
	setOrderInstruction()
	|
	repeatInstruction()
	| 
	groupInstruction()
	|
	skipInstruction()
	|
	ifInstruction()
	|
	setInstruction()
	|
	printInstruction()
	|
	markInstruction()
	|
	setEncodingInstruction()
	|
	defineInstruction()
	|
	includeInstruction()
	
}

void string() : {}
{
	(
		LOOKAHEAD(3)
		fixedString()
	|
		LOOKAHEAD(3)
		terminatedString()
	)	
}

void includeInstruction() : { Token t;}
{
	<INS_INCLUDE>
	(t=<IDENTIFIER>)
	{
		List<Instruction> include = defines.get(t.image);
		if(include == null) throw new RuntimeException("Could not get defined block with name " + t.image);
		instructions.addAll(include);
	}
}

void defineInstruction() : { Token t; }
{
	{
		instructionStack.push(instructions);
		instructions = new ArrayList<Instruction>();
	}

	<INS_DEFINE>
	<OPEN_PAR>
	(t=<IDENTIFIER>)
	<CLOSE_PAR>
	<OPEN_BRACE>
	list()
	<CLOSE_BRACE>
	
	{
		defines.put(t.image, instructions);
		instructions = instructionStack.pop();
	}
}

void setEncodingInstruction() : { Token t; }
{
	<INS_SETENCODING>
	(t=<ENCODING>)
	{ 
		this.defaultEncoding = t.image;
	}
}

void setInstruction() : { String s; Token t;}
{
	
	<INS_SET>
	(t=<IDENTIFIER>)
	(s=expression())
	{
		SetInstruction ins = new SetInstruction();
		ins.setVarname(t.image);
		ins.setExpression(s);
		instructions.add(ins);	
	}
}

void printInstruction() : { Token t; String s; }
{
	{ PrintInstruction ins = new PrintInstruction(); }
	<INS_PRINT>
	(
	LOOKAHEAD(3)
	(s=expression() { ins.setVar(s); })
	|
	LOOKAHEAD(3)
	(t=<IDENTIFIER> { ins.setVar(t.image); })
	)
	{ instructions.add(ins); }
}

void ifInstruction() : { String s;}
{
	{ 
	instructionStack.push(instructions);
	instructions = new ArrayList<Instruction>();
	IfBlock ins = new IfBlock();
	}
	<INS_IF>
	<OPEN_PAR>
	(s=expression())
	<CLOSE_PAR>
	<OPEN_BRACE>
	list()
	<CLOSE_BRACE>
	{
		ins.setIfExpression(s);
		ins.setInstructions(instructions);
		instructions = instructionStack.pop();
	}
	[ 
		LOOKAHEAD(2)
		[<EOL>]
		<INS_ELSE>
		[<EOL>]
		{
		 instructionStack.push(instructions);
		 instructions = new ArrayList<Instruction>();
		}
		<OPEN_BRACE>
		list()
		<CLOSE_BRACE>
		{
			ins.setElseInstructions(instructions);
			instructions = instructionStack.pop();
		}
	]
	
	{ instructions.add(ins); }
}

void setOrderInstruction() : { Token t;}
{
	<INS_SETORDER>
	(t=<BYTEORDER>) 
	{ 
	  SetOrderInstruction ins = new SetOrderInstruction();
	  ByteOrder order = null;
	  if(t.image.equals("LITTLE_ENDIAN")) {
	  	order = ByteOrder.LITTLE_ENDIAN;
	  } else {
	  	order = ByteOrder.BIG_ENDIAN;
	  }
	  ins.setOrder(order);
	  instructions.add(ins);
	}
}

void repeatInstruction() : { String s;}
{
	{ 
		instructionStack.push(instructions);
		instructions = new ArrayList<Instruction>();
	}
	<INS_REPEAT>
	<OPEN_PAR>
	(s=expression())
	<CLOSE_PAR>
	<OPEN_BRACE>
	list()
	<CLOSE_BRACE>
	
	{
		RepeatBlock ins = new RepeatBlock();
		ins.setRepeatCountExpression(s);
		ins.setInstructions(instructions);
		instructions = instructionStack.pop();
		instructions.add(ins);
	}
}

void groupInstruction() : { Token t; }
{
	
	<INS_GROUP>
	<OPEN_PAR>
	(t=<IDENTIFIER>)
	<CLOSE_PAR>
	{ 
	    GroupInstruction ins = new GroupInstruction();
		ins.setGroupName(t.image);
		instructions.add(ins); }
	<OPEN_BRACE>
	list()
	<CLOSE_BRACE>
	{
		EndGroupInstruction ins2 = new EndGroupInstruction();
		ins2.setGroupName(t.image);
		instructions.add(ins2);
	}	
}

void jumpInstruction() : { String s;}
{
	
	(<INS_JUMP> )
	((s=expression())) 
	
	{  
	    JumpInstruction ins = new JumpInstruction();
	    ins.setExpression(s); 
		instructions.add(ins);
	} 
}

void skipInstruction() : { String s;}
{
	<INS_SKIP>
	(s=expression())
	{
		SkipInstruction ins = new SkipInstruction();
		ins.setSizeExpression(s);
		instructions.add(ins);
	}
}

void markInstruction() : { Token t; }
{
	<INS_MARK>
	(t = <IDENTIFIER>)
	{
	  MarkInstruction ins = new MarkInstruction();
	  ins.setName(t.image);
	  instructions.add(ins);
	}
}

void fixedString() : { Token t4, t5; String s;}
{	
	{
	  FixedLengthString ins = new FixedLengthString();
	  ins.setEncoding(defaultEncoding);
	}
	<TY_STRING>
	<OPEN_PAR>
	(s=expression())
	[ <COMMA> (t5 = <ENCODING>) {ins.setEncoding(t5.image);}] 
	<CLOSE_PAR>
	(t4 = <IDENTIFIER>)
	{
	 ins.setLengthExpr(s);
	 ins.setName(t4.image);
	 instructions.add(ins);
	}
}

void terminatedString() : { Token t2, t3; }
{
 	{
	  TerminatedString ins = new TerminatedString();
	  ins.setEncoding(defaultEncoding);
	}	< TY_STRING >
	[ <OPEN_PAR > (t3 = <ENCODING>) < CLOSE_PAR > { ins.setEncoding(t3.image);	} ]
	( t2 = < IDENTIFIER > )	
	{
		ins.setName(t2.image);
		instructions.add(ins);
	}
}

void fixedNumber() : { Token t2, t4;}
{
	(t2=numberType())
	(t4=<IDENTIFIER>)
	
	{
		FixedLengthNumberFactory insF = new FixedLengthNumberFactory();
		ReferencedInstruction ins = insF.getInstruction(t2.image); 		
		ins.setName(t4.image);
		instructions.add(ins);
	}
}

void fixedUnsigned() : { Token t1, t2;}
{
	(t1=unsignedNumberType())
	(t2=<IDENTIFIER>)
	
	{
		FixedLengthUnsignedNumber ins = null;
		if(t1.image.equals("uint")){
			ins = new UnsignedIntegerInstruction();
		}else if(t1.image.equals("ubyte")){
			ins = new UnsignedByteInstruction();
		}else if(t1.image.equals("ulong")){
			ins = new UnsignedLongInstruction();
		}else if(t1.image.equals("ushort")){
			ins = new UnsignedShortInstruction();
		}		
		ins.setName(t2.image);
		instructions.add(ins);
	}
}

String expression() : { String s; Token t;}
{
	{StringBuffer b = new StringBuffer(); }
		
	(s=plusexpression()) { b.append(s);}
	[ (t=comparator())	{b.append(t.image);}
 	  (s=plusexpression()) {b.append(s);} ]

	{ return b.toString();}
}

Token comparator() : { Token t;}
{
	(
	(t=<EQUAL>)
	|
	(t=<GREATER_THAN>)
	|
	(t=<LESS_THAN>)
	|
	(t=<NOT_EQUAL>)
	|
	(t=<LESS_OR_EQUAL>)
	|
	(t=<GREATER_OR_EQUAL>)
	)
	{ return t; }
}

String plusexpression() : { Token t; String s;}
{
	{ StringBuffer expr = new StringBuffer(); } 
	( s=term()) { expr.append(s); }

	((t=<PL_MI_OPERATOR>) { expr.append(t.image); } 
	 (s=term()) { expr.append(s); })*
	 
	{ return expr.toString(); } 
}

String term() : { String s; Token t;}
{
	{ StringBuffer term = new StringBuffer(); }
	( s=operand())
	{ term.append(s);}
	((t=<MUL_DIV_OPERATOR>) { term.append(t.image);} (s=operand()) { term.append(s); } )*
	{ return term.toString(); }
}

String operand() : { Token t; String ex;}
{
	{ StringBuffer s = new StringBuffer(); }
	(
	LOOKAHEAD(4)
	(ex=functionCall()) {s.append(ex);}
	|
	(t=<INTEGER>) { s.append(t.image);}
	|
	(t=<ID_ADDRESS>) { String s1 = t.image; s.append(s1.substring(1,s1.length()) + ".address"); Evaluator.addExpression(t.image); }
	|
	(t=<ID_VALUE>) { s.append(t.image); Evaluator.addExpression(t.image); }
	|
	(t=<OPEN_PAR>) {s.append(t.image);} (ex=expression()) { s.append(ex);}  (t=<CLOSE_PAR>) {s.append(t.image);}
	|
	LOOKAHEAD(3)
	(t=<IDENTIFIER>){s.append(t.image); Evaluator.addExpression(t.image);}
	)
	{ return s.toString();}
}

String functionCall(): {Token t; String ex;}
{
  	(t=<IDENTIFIER>) 
  	(ex=FormalParameters()) 
  	{
  		StringBuffer b = new StringBuffer();
  		b.append(t.image);
  		b.append(ex);
  		return b.toString();
  	}
}

String FormalParameters(): { String ex;}
{
	{StringBuffer b = new StringBuffer();}
  	<OPEN_PAR>  {b.append("(");} 
  	[ 
  		(ex=FormalParameter()) {b.append(ex);} 
  		( 	"," 
  			(ex=FormalParameter()) {b.append(","); b.append(ex);} 
  		)* 
  	] 
  	
  	<CLOSE_PAR>  {b.append(")");}
  	
  	{return b.toString();}
}

String FormalParameter(): { Token t;}
{
	[ "(" numberType() ")" ]
	
	(
	(t=<IDENTIFIER>) { Evaluator.addExpression(t.image); }
	|
	(t=<INTEGER>)
	|
	(t=<FLOAT>)
	|
	(t=<ID_VALUE>) { Evaluator.addExpression(t.image); }
	|
	(t=<ID_ADDRESS>)  { Evaluator.addExpression(t.image); }
	)
	{System.out.println("Param:" + t.image); return t.image;}
}

Token numberType() : { Token t; }
{
	(
	(t=<TY_DOUBLE>)
	|
	(t=<TY_INT>)
	|
	(t=<TY_BYTE>)
	|
	(t=<TY_FLOAT>)
	|
	(t=<TY_SHORT>)
	|
	(t=<TY_LONG>)
	)
	{return t;} 
}

Token unsignedNumberType() : { Token t; }
{
	(
	(t=<TY_UBYTE>)
	|
	(t=<TY_USHORT>)
	|
	(t=<TY_ULONG>)
	| 
	(t=<TY_UINT>)
	)
	{return t;} 
}

