/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. spiff.jj */
/*@egen*/options{  STATIC = false;  DEBUG_TOKEN_MANAGER = false;  DEBUG_PARSER = false;}PARSER_BEGIN(SpiffTreeParser)/******************************************************************************* * This file is part of SPIFF. *  * SPIFF is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. *  * SPIFF is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. *  * You should have received a copy of the GNU General Public License * along with SPIFF.  If not, see <http://www.gnu.org/licenses/>. ******************************************************************************/package com.revbingo.spiff.parser;import com.revbingo.spiff.AdfFormatException;import com.revbingo.spiff.instructions.*;import com.revbingo.spiff.datatypes.*;import com.revbingo.spiff.evaluator.Evaluator;import com.revbingo.spiff.parser.InstructionParser;import java.util.*;import java.nio.ByteOrder;import java.nio.charset.Charset;public class SpiffTreeParser/*@bgen(jjtree)*/implements SpiffTreeParserTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected JJTSpiffTreeParserState jjtree = new JJTSpiffTreeParserState();

/*@egen*/  private List <Instruction> instructions = new ArrayList <Instruction> ();  private Stack <List<Instruction>> instructionStack = new Stack <List <Instruction>> ();  private Map <String, List<Instruction>> defines = new HashMap <String, List<Instruction>> ();  private Map <String, Class<Datatype>> datatypes = new HashMap<String, Class<Datatype>>();  private Evaluator evaluator = new Evaluator();    private String defaultEncoding = Charset.defaultCharset().displayName();  public void optimise() {    List <Instruction> allInsts = flatten(instructions);    for (Instruction i : allInsts) {      if (i instanceof Datatype) {        Datatype ri = (Datatype) i;        if (!evaluator.isReferenced(ri.getName())) {          ri.setReferenced(false);        }      }    }  }  public List<Instruction> getInstructions() {  	optimise();  	return instructions;  }    private List <Instruction> flatten(List <Instruction> insts) {    List <Instruction> a = new ArrayList <Instruction> ();    for (Instruction i : insts) {      if (i instanceof Block) {        a.addAll(flatten(((Block) i).getInstructions()));      } else {        a.add(i);      }    }    return a;  }}PARSER_END(SpiffTreeParser)SKIP :{  " " | "\t"}TOKEN : /* TYPES */{  < TY_STRING : "string" >| < TY_INT : "int" >| < TY_LONG : "long" >| < TY_BYTE : "byte" >| < TY_SHORT : "short" >| < TY_DOUBLE : "double" >| < TY_FLOAT : "float" >| < TY_UBYTE : "ubyte" >| < TY_USHORT : "ushort" >| < TY_UINT : "uint" >| < TY_ULONG : "ulong" >| < TY_BITS : "bits" >| < TY_BYTES : "bytes" >}TOKEN : /* LITERALS */{  < EOL :    "\n"  | "\r"  | "\r\n" >| < BYTEORDER :    "LITTLE_ENDIAN"  | "BIG_ENDIAN" >| < ENCODING :    "UTF-16LE"  | "UTF-16BE"  | "UTF-8"  | "US-ASCII" >| < END :    "end"  | "END" >| < OPEN_PAR : "(" >| < CLOSE_PAR : ")" >| < OPEN_BRACE : "{" >| < CLOSE_BRACE : "}" >| < COMMA : "," >| < QUOTE : "'" >}TOKEN : /* INSTRUCTIONS */{  < INS_JUMP : ".jump" >| < INS_SETORDER : ".setorder" >| < INS_REPEAT : ".repeat" >| < INS_GROUP : ".group" >| < INS_SKIP : ".skip" >| < INS_IF : ".if" >| < INS_SET : ".set" >| < INS_PRINT : ".print" >| < INS_ELSE : ".else" >| < INS_MARK : ".mark" >| < INS_SETENCODING : ".setencoding" >| < INS_DEFINE : ".define" >| < INS_INCLUDE : ".include" >| < INS_DATATYPE : ".datatype" >}TOKEN : /* OPERATORS */{  < EQUAL : "==" >| < GREATER_THAN : ">" >| < LESS_THAN : "<" >| < NOT_EQUAL : "!=" >| < GREATER_OR_EQUAL : ">=" >| < LESS_OR_EQUAL : "<=" >| < PL_MI_OPERATOR : "+" | "-" >| < MUL_DIV_OPERATOR : "*" | "/" | "%" >}TOKEN : /* OTHERS */{ < IDENTIFIER : (< ALPHA > | < UNDERSCORE >) (< ALPHANUM > | < UNDERSCORE >)* >| < ID_VALUE : < IDENTIFIER > ".value" >| < CLASS : (<ALPHA>)+ (("."|"$") (<ALPHANUM>)+ )* >| < ID_ADDRESS : "&" < IDENTIFIER > >| < COMMENT : "#" (~[ "\n", "\r" ])* >| < FLOAT : (< DIGIT >)+ "." (< DIGIT >)+ >| < HEX_INTEGER : "0x" (["A"-"F","a"-"f","0"-"9"])* >| < INTEGER : ("-")? (< DIGIT >)+ >| < #ALPHANUM : < ALPHA > | < DIGIT > >| < #DIGIT : [ "0"-"9" ] >| < #ALPHA : [ "a"-"z", "A"-"Z" ] >| < #UNDERSCORE : "_" >}SimpleNode adf() : {/*@bgen(jjtree) adf */
  SimpleNode jjtn000 = new SimpleNode(JJTADF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) adf */
  try {
/*@egen*/  datatypeDefs()  list()  (< EOL >)*   < EOF >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/    { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void datatypeDefs() :{/*@bgen(jjtree) datatypeDefs */
  SimpleNode jjtn000 = new SimpleNode(JJTDATATYPEDEFS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token id, clazz; }{/*@bgen(jjtree) datatypeDefs */
        try {
/*@egen*/	(		<INS_DATATYPE> (id=<IDENTIFIER>) (clazz=<CLASS>) <EOL>				{			try {				Class<Datatype> datatypeClass = (Class<Datatype>) Class.forName(clazz.image);				if(!Datatype.class.isAssignableFrom(datatypeClass)) {					throw new AdfFormatException("Custom datatype " + datatypeClass + " does not extend com.revbingo.spiff.datatypes.Datatype");				}				datatypes.put(id.image, datatypeClass);			} catch (ClassNotFoundException e) {				throw new AdfFormatException("Unknown datatype class " + clazz.image);			}					}	)*/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/}void list() :{/*@bgen(jjtree) list */
  SimpleNode jjtn000 = new SimpleNode(JJTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) list */
  try {
/*@egen*/  (    [      (        entry()      |         instruction()      )    ]    [ < COMMENT > ]     < EOL >  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void entry() :{/*@bgen(jjtree) entry */
  SimpleNode jjtn000 = new SimpleNode(JJTENTRY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t1, t2; }{/*@bgen(jjtree) entry */
  try {
/*@egen*/  (    LOOKAHEAD(8)    string()  |     LOOKAHEAD(2)    fixedNumber()  |     LOOKAHEAD(2)    fixedUnsigned()  |  	bits()  |   	bytes()  |	  	//user defined datatype  	(t1=<IDENTIFIER>) (t2=<IDENTIFIER>)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/  	  	{	  		Class<Datatype> userType = datatypes.get(t1.image);  		if(userType == null) {  			throw new AdfFormatException("Undefined datatype " + t1.image);  		}  		try {  			Datatype inst = userType.newInstance();  			inst.setName(t2.image);  			instructions.add(inst);  		} catch (InstantiationException e) {			throw new AdfFormatException("Custom datatype " + userType.getName() + " does not have a no-args constructor or threw an exception");		} catch (IllegalAccessException e) {			throw new AdfFormatException("Custom datatype " + userType.getName() + " does not have a publically accessible no args constructor");		}  	}  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void bits() :{/*@bgen(jjtree) bits */
        SimpleNode jjtn000 = new SimpleNode(JJTBITS);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/ 	Token t2; 	String expr;}{/*@bgen(jjtree) bits */
        try {
/*@egen*/	<TY_BITS> <OPEN_PAR> (expr = expression()) < CLOSE_PAR> (t2=<IDENTIFIER>)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/		{		BitsInstruction inst = new BitsInstruction();		inst.setName(t2.image);		inst.setNumberOfBitsExpr(expr);				instructions.add(inst);	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	}void bytes() :{/*@bgen(jjtree) bytes */
        SimpleNode jjtn000 = new SimpleNode(JJTBYTES);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/ 	Token t2; 	String expr;}{/*@bgen(jjtree) bytes */
        try {
/*@egen*/	<TY_BYTES> <OPEN_PAR> (expr = expression()) < CLOSE_PAR> (t2=<IDENTIFIER>)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/		{		BytesInstruction inst = new BytesInstruction();		inst.setName(t2.image);		inst.setLengthExpr(expr);				instructions.add(inst);	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	}void instruction() :{/*@bgen(jjtree) instruction */
  SimpleNode jjtn000 = new SimpleNode(JJTINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) instruction */
  try {
/*@egen*/  jumpInstruction()|   setOrderInstruction()|   repeatInstruction()|   groupInstruction()|   skipInstruction()|   ifInstruction()|   setInstruction()|   printInstruction()|   markInstruction()|   setEncodingInstruction()|   defineInstruction()|   includeInstruction()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void string() :{/*@bgen(jjtree) string */
  SimpleNode jjtn000 = new SimpleNode(JJTSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) string */
  try {
/*@egen*/  (  	LOOKAHEAD(3)  	literalString()  |    LOOKAHEAD(3)    fixedString()  |     LOOKAHEAD(3)    terminatedString()  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/  }void includeInstruction() :{/*@bgen(jjtree) includeInstruction */
  SimpleNode jjtn000 = new SimpleNode(JJTINCLUDEINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) includeInstruction */
  try {
/*@egen*/  < INS_INCLUDE >   (t = < IDENTIFIER >)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    List<Instruction> include = defines.get(t.image);    if (include == null) {    	throw new AdfFormatException("Could not get defined block with name " + t.image);    }    instructions.addAll(include);  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void defineInstruction() :{/*@bgen(jjtree) defineInstruction */
  SimpleNode jjtn000 = new SimpleNode(JJTDEFINEINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) defineInstruction */
  try {
/*@egen*/  {    instructionStack.push(instructions);    instructions = new ArrayList < Instruction > ();  }  < INS_DEFINE >   < OPEN_PAR >   (t = < IDENTIFIER >)   < CLOSE_PAR >   < OPEN_BRACE >   list()   < CLOSE_BRACE >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    defines.put(t.image, instructions);    instructions = instructionStack.pop();  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void setEncodingInstruction() :{/*@bgen(jjtree) setEncodingInstruction */
  SimpleNode jjtn000 = new SimpleNode(JJTSETENCODINGINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) setEncodingInstruction */
  try {
/*@egen*/  < INS_SETENCODING >   (t = < ENCODING >)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    this.defaultEncoding = t.image;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void setInstruction() :{/*@bgen(jjtree) setInstruction */
  SimpleNode jjtn000 = new SimpleNode(JJTSETINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  String s;  Token t;}{/*@bgen(jjtree) setInstruction */
  try {
/*@egen*/  < INS_SET >   (t = < IDENTIFIER >)  (    s = expression()  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    SetInstruction ins = new SetInstruction();    ins.setVarname(t.image);    ins.setExpression(s);    instructions.add(ins);  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void printInstruction() :{/*@bgen(jjtree) printInstruction */
  SimpleNode jjtn000 = new SimpleNode(JJTPRINTINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;  String s;}{/*@bgen(jjtree) printInstruction */
  try {
/*@egen*/  {    PrintInstruction ins = new PrintInstruction();  }  < INS_PRINT >  (    LOOKAHEAD(3)    (      s = expression()      {        ins.setVar(s);      }    )  |     LOOKAHEAD(3)    (      t = < IDENTIFIER >      {        ins.setVar(t.image);      }    )  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    instructions.add(ins);  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void ifInstruction() :{/*@bgen(jjtree) ifInstruction */
  SimpleNode jjtn000 = new SimpleNode(JJTIFINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  String s;}{/*@bgen(jjtree) ifInstruction */
  try {
/*@egen*/  {    instructionStack.push(instructions);    instructions = new ArrayList < Instruction > ();    IfBlock ins = new IfBlock();  }  < INS_IF >   < OPEN_PAR >  (    s = expression()  )  < CLOSE_PAR >   < OPEN_BRACE >   list()   < CLOSE_BRACE >  {    ins.setIfExpression(s);    ins.setInstructions(instructions);    instructions = instructionStack.pop();  }  [    LOOKAHEAD(2)    [ < EOL > ]     < INS_ELSE >     [ < EOL > ]    {      instructionStack.push(instructions);      instructions = new ArrayList < Instruction > ();    }    < OPEN_BRACE >     list()     < CLOSE_BRACE >    {      ins.setElseInstructions(instructions);      instructions = instructionStack.pop();    }  ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    instructions.add(ins);  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void setOrderInstruction() :{/*@bgen(jjtree) setOrderInstruction */
  SimpleNode jjtn000 = new SimpleNode(JJTSETORDERINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) setOrderInstruction */
  try {
/*@egen*/  < INS_SETORDER >   (t = < BYTEORDER >)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    SetOrderInstruction ins = new SetOrderInstruction();    ByteOrder order = null;    if (t.image.equals("LITTLE_ENDIAN"))    {      order = ByteOrder.LITTLE_ENDIAN;    }    else    {      order = ByteOrder.BIG_ENDIAN;    }    ins.setOrder(order);    instructions.add(ins);  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void repeatInstruction() :{/*@bgen(jjtree) repeatInstruction */
  SimpleNode jjtn000 = new SimpleNode(JJTREPEATINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  String s;}{/*@bgen(jjtree) repeatInstruction */
  try {
/*@egen*/  {    instructionStack.push(instructions);    instructions = new ArrayList < Instruction > ();  }  < INS_REPEAT >   < OPEN_PAR >  (    s = expression()  )  < CLOSE_PAR >   < OPEN_BRACE >   list()   < CLOSE_BRACE >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    RepeatBlock ins = new RepeatBlock();    ins.setRepeatCountExpression(s);    ins.setInstructions(instructions);    instructions = instructionStack.pop();    instructions.add(ins);  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void groupInstruction() :{/*@bgen(jjtree) groupInstruction */
  SimpleNode jjtn000 = new SimpleNode(JJTGROUPINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) groupInstruction */
  try {
/*@egen*/  < INS_GROUP >   < OPEN_PAR >   (t = < IDENTIFIER >)   < CLOSE_PAR >  {    GroupInstruction ins = new GroupInstruction();    ins.setGroupName(t.image);    instructions.add(ins);  }  < OPEN_BRACE >   list()   < CLOSE_BRACE >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    EndGroupInstruction ins2 = new EndGroupInstruction();    ins2.setGroupName(t.image);    instructions.add(ins2);  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void jumpInstruction() :{/*@bgen(jjtree) jumpInstruction */
  SimpleNode jjtn000 = new SimpleNode(JJTJUMPINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  String s;}{/*@bgen(jjtree) jumpInstruction */
  try {
/*@egen*/  (< INS_JUMP >)  (    (      s = expression()    )  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    JumpInstruction ins = new JumpInstruction();    ins.setExpression(s);    instructions.add(ins);  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void skipInstruction() :{/*@bgen(jjtree) skipInstruction */
  SimpleNode jjtn000 = new SimpleNode(JJTSKIPINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  String s;}{/*@bgen(jjtree) skipInstruction */
  try {
/*@egen*/  < INS_SKIP >  (    s = expression()  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    SkipInstruction ins = new SkipInstruction();    ins.setSizeExpression(s);    instructions.add(ins);  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void markInstruction() :{/*@bgen(jjtree) markInstruction */
  SimpleNode jjtn000 = new SimpleNode(JJTMARKINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) markInstruction */
  try {
/*@egen*/  < INS_MARK >   (t = < IDENTIFIER >)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    MarkInstruction ins = new MarkInstruction();    ins.setName(t.image);    instructions.add(ins);  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void fixedString() :{/*@bgen(jjtree) fixedString */
  SimpleNode jjtn000 = new SimpleNode(JJTFIXEDSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t4, t5;  String s;}{/*@bgen(jjtree) fixedString */
  try {
/*@egen*/  {   	String encoding = defaultEncoding;   }  < TY_STRING >   < OPEN_PAR >  (    s = expression()  )  [    < COMMA > (t5 = < ENCODING >)    {     	encoding = t5.image;    }  ]  < CLOSE_PAR >   (t4 = < IDENTIFIER >)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {  	FixedLengthString ins = new FixedLengthString(encoding);    ins.setLengthExpr(s);    ins.setName(t4.image);    instructions.add(ins);  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void literalString() :{/*@bgen(jjtree) literalString */
   SimpleNode jjtn000 = new SimpleNode(JJTLITERALSTRING);
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
/*@egen*/   Token t1, t4, t5;}{/*@bgen(jjtree) literalString */
  try {
/*@egen*/  <TY_STRING>     {   	String encoding = defaultEncoding;   }   <OPEN_PAR>   	<QUOTE>   		(t1 = <IDENTIFIER>)  	<QUOTE> 	[ < COMMA > (t5 = < ENCODING >)	    {	      encoding = t5.image;	    }	 ]    <CLOSE_PAR>  (t4 = < IDENTIFIER >)/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/      {   	LiteralStringInstruction ins = new LiteralStringInstruction(encoding);   	instructions.add(ins);   	ins.setName(t4.image);   	ins.setLiteral(t1.image);   }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ }void terminatedString() :{/*@bgen(jjtree) terminatedString */
  SimpleNode jjtn000 = new SimpleNode(JJTTERMINATEDSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t2, t3;}{/*@bgen(jjtree) terminatedString */
  try {
/*@egen*/  {	String encoding = defaultEncoding;     }  < TY_STRING >  [    < OPEN_PAR > (t3 = < ENCODING >) < CLOSE_PAR >    {      encoding = t3.image;    }  ]  (t2 = < IDENTIFIER >)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {   	TerminatedString ins = new TerminatedString(encoding);    ins.setName(t2.image);    instructions.add(ins);  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void fixedNumber() :{/*@bgen(jjtree) fixedNumber */
  SimpleNode jjtn000 = new SimpleNode(JJTFIXEDNUMBER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t2, t4;}{/*@bgen(jjtree) fixedNumber */
  try {
/*@egen*/  (    t2 = numberType()  )  (t4 = < IDENTIFIER >)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    FixedLengthNumberFactory insF = new FixedLengthNumberFactory();    Datatype ins = insF.getInstruction(t2.image);    ins.setName(t4.image);    instructions.add(ins);  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void fixedUnsigned() :{/*@bgen(jjtree) fixedUnsigned */
  SimpleNode jjtn000 = new SimpleNode(JJTFIXEDUNSIGNED);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t1, t2;}{/*@bgen(jjtree) fixedUnsigned */
  try {
/*@egen*/  (    t1 = unsignedNumberType()  )  (t2 = < IDENTIFIER >)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    FixedLengthUnsignedNumber ins = null;    if (t1.image.equals("uint"))    {      ins = new UnsignedIntegerInstruction();    }    else if (t1.image.equals("ubyte"))    {      ins = new UnsignedByteInstruction();    }    else if (t1.image.equals("ulong"))    {      ins = new UnsignedLongInstruction();    }    else if (t1.image.equals("ushort"))    {      ins = new UnsignedShortInstruction();    }    ins.setName(t2.image);    instructions.add(ins);  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}String expression() :{/*@bgen(jjtree) expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  String s;  Token t;}{/*@bgen(jjtree) expression */
  try {
/*@egen*/  {StringBuffer b = new StringBuffer();}    (s = additiveExpression())  { b.append(s); }    (    (t = comparator())  { b.append(t.image); }    (s = additiveExpression())  { b.append(s); }  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/    {    return b.toString();  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}Token comparator() :{/*@bgen(jjtree) comparator */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMPARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) comparator */
  try {
/*@egen*/  (    (t = < EQUAL >)  |     (t = < GREATER_THAN >)  |     (t = < LESS_THAN >)  |     (t = < NOT_EQUAL >)  |     (t = < LESS_OR_EQUAL >)  |     (t = < GREATER_OR_EQUAL >)  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return t;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}String additiveExpression() :{/*@bgen(jjtree) additiveExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTADDITIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;  String s;}{/*@bgen(jjtree) additiveExpression */
  try {
/*@egen*/  {    StringBuffer expr = new StringBuffer();  }  (    s = multiplicativeExpression()  )  {    expr.append(s);  }     (	    (t = < PL_MI_OPERATOR >)	    {	      expr.append(t.image);	    }	    (	      s = multiplicativeExpression()	    )	    {	      expr.append(s);	    }	  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return expr.toString();  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}String multiplicativeExpression() :{/*@bgen(jjtree) multiplicativeExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTMULTIPLICATIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  String s;  Token t;}{/*@bgen(jjtree) multiplicativeExpression */
  try {
/*@egen*/  {    StringBuffer term = new StringBuffer();  }  (    s = unaryExpression()  )  {    term.append(s);  }  (    (t = < MUL_DIV_OPERATOR >)    {      term.append(t.image);    }    (      s = unaryExpression()    )    {      term.append(s);    }  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return term.toString();  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}String unaryExpression() :{/*@bgen(jjtree) unaryExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTUNARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;  String ex;}{/*@bgen(jjtree) unaryExpression */
  try {
/*@egen*/  {    StringBuffer s = new StringBuffer();  }  (    LOOKAHEAD(2)    (      ex = functionCall()    )    {      s.append(ex);    }  |     (t = < IDENTIFIER >)    {      s.append(t.image);      evaluator.cacheExpression(t.image);    }  |     (t = < INTEGER >)    {      s.append(t.image);    }  |   	(t = < HEX_INTEGER>)  	{  		s.append(t.image);  	}  |    (t = < ID_ADDRESS >)    {      String s1 = t.image;      s.append(s1.substring(1, s1.length()) + ".address");      evaluator.cacheExpression(t.image);    }  |     (t = < ID_VALUE >)    {      s.append(t.image);      evaluator.cacheExpression(t.image);    }  |     (t = < OPEN_PAR >)    {      s.append(t.image);    }    (      ex = expression()    )    {      s.append(ex);    }    (t = < CLOSE_PAR >)    {      s.append(t.image);    }  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return s.toString();  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}String functionCall() :{/*@bgen(jjtree) functionCall */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONCALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;  String ex;}{/*@bgen(jjtree) functionCall */
  try {
/*@egen*/  (t = < IDENTIFIER >)   < OPEN_PAR >  (    ex = FormalParameters()  )  < CLOSE_PAR >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    StringBuffer b = new StringBuffer();    b.append(t.image);    b.append(ex);    return b.toString();  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}String FormalParameters() :{/*@bgen(jjtree) FormalParameters */
  SimpleNode jjtn000 = new SimpleNode(JJTFORMALPARAMETERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  String ex;}{/*@bgen(jjtree) FormalParameters */
  try {
/*@egen*/  {    StringBuffer b = new StringBuffer();    b.append("(");  }  [    (      ex = FormalParameter()    )    {      b.append(ex);    }    (      ","      (        ex = FormalParameter()      )      {        b.append(",");        b.append(ex);      }    )*  ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    b.append(")");    return b.toString();  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}String FormalParameter() :{/*@bgen(jjtree) FormalParameter */
  SimpleNode jjtn000 = new SimpleNode(JJTFORMALPARAMETER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t = null;  String expr;}{/*@bgen(jjtree) FormalParameter */
  try {
/*@egen*/  (      LOOKAHEAD(2)      (expr = expression())      { return expr; }  |    (t = < IDENTIFIER >)    {      evaluator.cacheExpression(t.image);    }  |     (t = < INTEGER >)  |     (t = < FLOAT >)  |     (t = < ID_VALUE >)    {      evaluator.cacheExpression(t.image);    }  |     (t = < ID_ADDRESS >)    {      evaluator.cacheExpression(t.image);    }      )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return t.image;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}Token numberType() :{/*@bgen(jjtree) numberType */
  SimpleNode jjtn000 = new SimpleNode(JJTNUMBERTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) numberType */
  try {
/*@egen*/  (    (t = < TY_DOUBLE >)  |     (t = < TY_INT >)  |     (t = < TY_BYTE >)  |     (t = < TY_FLOAT >)  |     (t = < TY_SHORT >)  |     (t = < TY_LONG >)  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return t;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}Token unsignedNumberType() :{/*@bgen(jjtree) unsignedNumberType */
  SimpleNode jjtn000 = new SimpleNode(JJTUNSIGNEDNUMBERTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) unsignedNumberType */
  try {
/*@egen*/  (    (t = < TY_UBYTE >)  |     (t = < TY_USHORT >)  |     (t = < TY_ULONG >)  |     (t = < TY_UINT >)  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return t;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}
